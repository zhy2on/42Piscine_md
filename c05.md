# C05
## ex00 : ft_iterative_factorial
* 반복문을 이용한 팩토리얼 함수
* 음수는 0 리턴, 0팩토리얼은 1 리턴 예외처리
* 이후 nb가 1이 될 때까지 빼며 리턴값에 곱해준다.

## ex01 : ft_recursive_factorial
* 재귀를 이용한 팩토리얼 함수
* 음수는 0리턴, 0은 1리턴 예외처리 -->양수로 들어왔다면 계속 nb값이 빠지다가 0일 때 1을 리턴시킨다.
* nb를 1씩 빼면서 재귀함수의 매개변수로 넘긴다.

## ex02 : ft_iterative_power
* 반복문을 이용한 거듭제곱 함수
* 0승은 1, 음수승은 0 리턴
* 이미 nb로 시작하니까 이를 하나로 보고 power - 1 만큼 거듭제곱 해줘야 한다. 따라서 while문 조건은 --power

## ex03 : ft_recursive_power
* 재귀를 이용한 거듭제곱 함수
* 0승은 1, 음수승은 0 리턴 -->양수로 들어왔다면 계속 nb값이 빠지다가 0일 때 1을 리턴시킨다.
* power를 1씩 빼면서 재귀함수의 매개변수로 넘긴다.

## ex04 : ft_fibonacci
* 재귀를 이용한 피보나치 함수
* 음수일 때 -1 리턴 예외처리
* fibo(n) = 0(n == 0), 1(n == 1), n - 1 + n - 2(n > 1)

## ex05 : ft_sqrt
* 반복문을 이용한 제곱근 함수
* while문 조건에서 i * i가 int형 범위를 초과화게 되는 경우가 발생한다.
* 46340 * 46340의 경우 2147395600로 int형 범위 내이지만, 46341 46341은 2147488281로 int형 범위를 초과하게 된다. 따라서 nb가 2147395601~2147483647인 경우 
올바른 값이 나오지 않게 된다. 때문에 i를 int가 아닌 다른 더 큰 범위를 가진 자료형으로 선언해줘야 한다.
* 이 때 unsigned int 자료형과 int형이 비교되기 때문에 gcc에서 에러가 난다. nb를 unsigned int로 강제 형변환을 해줘야 한다.

## ex06 : ft_is_prime
* <https://myjamong.tistory.com/139>
* 마지막 풀이는 두번째 풀이의 원리를 조금 인용해서 소수를 판별하는 가장 효율적인 방법이라고 생각한다. 해당 숫자의 √N 까지 확인하는 방법이다. 이 원리는 약수의 중심을 구하는 방법이다. 
* 예를들어 80의 약수는 아래와 같다.
* 1, 2, 4, 5, 8, 10, 16, 20, 40, 80
* 각 숫자들의 곱이 80이되는 쌍을 같은 색으로 표시했다. 1:80, 2:40, 4:20, 5:16, 8:10. √80의 값은 대략 8.xxx의 값이 나온다. 즉 약수들의 곱으로 봤을때 루트를 씌운 값이 중간값이 된다. 
이 원리는 이용하여 2에서부터 √N의 값까지 검색을한다며 이후의 값은 확인할 필요가 없게 된고 시간복잡도는 O(√N)이 된다. 코드의 가독성을 위해 루트함수는 사용하지 않고 i의 제곱값으로 확인을한다.
* 이 경우도 마찬가지로 i * i 가 nb범위를 초과하는 경우를 막기 위해 unsigned int로 선언해 줬다.
* 이 때 unsigned int 자료형과 int형이 비교되기 때문에 gcc에서 에러가 난다. nb를 unsigned int로 강제 형변환을 해줘야 한다.

## ex07 : ft_find_next_prime
* nb가 3보다 작은 경우 가장 큰 prime은 2
* nb가 짝수인 경우 다음 홀수부터 while문을 시작하게 함
* 큰 while문은 isprime과 같다. i = 3 부터 시작해서 +2씩 홀수로만 증가시켜서 nb의 제곱근까지만 while문을 돌게 한다. 
* 이 때 nb가 소수가 아니라면 nb를 또 2씩 증가해서 다시 while문을 돌게 한다.

## ex08 : The Ten Queens
* 
