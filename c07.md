# C07
## ex00 : ft_strdup
* strdup
  - strdup() 함수는 문자 s 를 복사하고 복사된 문자열을 가리키는 포인터를 반환한다. 문자를 복사할 공간을 확보하기 위해서 내부적으로 malloc(3)이 호출된다.
  - 복사된 문자열의 주소를 가리키는 포인터를 반환한다. 에러발생시에는 NULL 을 되돌려준다.

* malloc
  - memory allocation
  - 동적할당이라는 것은 프로그램 실행중에 동적으로 메모리를 할당하는 것을 말한다.
  - 함수 원형은 void* malloc(size_t size) 로, 동적할당 후 해당 데이터 타입으로 형변환을 해줘야 한다. 또한 메모리 크기는 자료형마다 다르기 때문에 sizeof()을 사용하여 자료형의 크기에 원하는 할당 크기를 곱해준다.

## ex01 : ft_range
* 최솟값이 최댓값보다 크거나 같으면 널포인터를 반환하게 예외처리
* min은 포함, max는 미포함이니 size는 max - min으로 설정해주면 된다.
* min부터 max보다 작은 값을 연속되게 배열에 넣는 것이니, 그냥 min을 증가연산하면서 max보다 작을 때까지 배열에 채워준다.

## ex02 : ft_ultimate_range
* 이번에는 배열을 채우고, 배열의 사이즈를 반환한다.
* 최솟값이 최댓값보다 크거나 같을 때 0을 반환하게 예외처리
* min은 포함, max는 미포함이니 size는 max - min으로 설정해주면 된다.
* ft_range와 똑같이 채운다.
* 이번에는 배열의 크기(i)를 반환한다.

## ex03 : ft_strjoin
* strs를 size만큼 돌며 각 문자열의 크기만큼 더한 값을 구해주고, 이후 sep문자열의 길이를 size - 1만큼 곱한 값을 더해 총 할당할 길이를 구해준다. (sep문자열은 마지막엔 안 붙으니까)
* 이후 strs[0]부터 돌면서 먼저 strs[0]을 dest에 붙여넣어주고 sep문자열을 그 뒤에 붙여주는 것을 size - 1 만큼 반복해준다.
* while문을 나와 맨 마지막 문자열은 sep문자열 복사 없이 그냥 strs[size - 1]만 복사하고 끝낸다. 이 때, 문제에서 size가 0인 경우는 그냥 메모리를 해제할 수 있는 포인터를 반환하라고 했기 때문에 size가 0이 아닐 때만 복사하게끔 하고 종료한다.

## ex04 : ft_convert_base
* ```c char \*nbr(base_from) -> int nbr(10) -> char\*ret(base_to)```
* 문자열로 들어온 base_from진법 숫자를 int형으로 바꾼 뒤, 그 숫자를 다시 base_to진법으로 바꾸는 식으로 진행했다.
* 구체적으로 적자면, ```c char \*nbr -> ft_atoi_base(nbr) -> int convert_nbr -> ft_itoa_base(convert_nbr)```식으로 진행한다.
* 이 때 ft_atoi_base는 앞에서 썼던 함수를 그대로 적용한다. 대신 ft_convert_base의 큰 틀은 앞에서 썼던 put_nbr을 응용해 적용한다.
* 어떻게 응용했는지는 다음과 같다. put_nbr에서는 바로 출력을 해줬기 때문에, 재귀로 함수를 사용했다. 하지만 여기선 배열에 각 숫자를 저장해야 한다. 따라서 배열 인덱스에 대한 접근과, 숫자가 -, +일 때 각각 구분해 줄 수 있는 플래그가 필요하다.
* put_nbr때와 같이 일의 자리 숫자만 일단 떼어놓고, nbr / len 을 해준 값을 itoa함수로 넘겨준다. 이 때 음수는 양수로 바꿔 전달하므로 플래그값을 따로 둬 음수일 때 구분하여 처리할 수 있게 해준다.
* 음수를 따로 처리해야 하는 이유는 음수일 때는 0번째에 '-'부호를 붙이고 그 다음부터 배열을 채워야 하기 때문이다.
* itoa함수에서 차례로 숫자를 채우고 마지막 인덱스를 반환해준다. 이전에 일의자리 숫자를 빼고 진행했기 때문에 itoa함수에서 반환한 인덱스에 전에 빼뒀던 일의자리 숫자 base[nbr % len]을 넣어주고, 그 다음 문자는 널문자가 들어가야하므로 i+1인덱스에 널문자를 넣어주고 ret문자열을 리턴해준다. 
